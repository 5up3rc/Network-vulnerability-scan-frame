#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <list>

#include "comm.h"

using namespace std;

ServerComm *pgl_Server_Comm=NULL;
RecvThread *pgl_Recv_Thread=NULL;

list<RECV_EVENT> gl_Event_List;
pthread_mutex_t gl_EventListMutex;

extern Task *pgl_Task;

ServerComm::ServerComm(CMD_OPTIONS &options)
{
    this->options=options;
    pthread_mutex_init(&sendMutex,NULL);

    return;
}

int ServerComm::connect_to_server()
{
    addr.sin_addr.s_addr=inet_addr(this->options.serverIP);
    addr.sin_family=AF_INET;
    addr.sin_port=htons(this->options.serverPort);

    soc=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    if(soc==INVALID_SOCKET)
    {
        cout <<"create socket failed"<<endl;
        return -1;
    }

    if(connect(soc,(struct sockaddr *)&addr,sizeof(addr))!=0)
    {
        cout <<"connect failed"<<endl;
        return -3;
    }

    pgl_Recv_Thread=new RecvThread(soc);
    pgl_Recv_Thread->run(NULL);

    if(client_auth()!=0)
        return -4;

    return 0;
}

int ServerComm::client_auth()
{
    PROTO_CLIENT_AUTH clientAuthPacket,*pReponse=NULL;

    memset(&clientAuthPacket,NULL,sizeof(clientAuthPacket));

    strcat(clientAuthPacket.authKey,this->options.key);
    if(ex_send(&clientAuthPacket,E_PROTO_CLIENT_AUTH)<=0)
        return -1;
    pReponse=(PROTO_CLIENT_AUTH *)wait_event(E_PROTO_CLIENT_AUTH,5000);
    if(pReponse==NULL)
    {
        cout <<"Auth timeout"<<endl;
        return -2;
    }
    if(pReponse->authStatus==0)
    {
        cout <<"Key invalid"<<endl;
        return -3;
    }
    pgl_Server_Comm->clientType=pReponse->authStatus;
    cout <<"client type:"<<pReponse->authStatus<<endl;
    free(pReponse);

    return 0;
}

int ServerComm::upload_file(FILE *srcFile,char *fileName,int fileType)
{
    PROTO_FILE_TRAN fileTranPacket;

    while(!feof(srcFile))
    {
        memset(&fileTranPacket,NULL,sizeof(fileTranPacket));

        fileTranPacket.fileType=fileType;
        strcat(fileTranPacket.fileName,fileName);
        fileTranPacket.dataSize=fread(fileTranPacket.fileData,sizeof(char),sizeof(fileTranPacket.fileData)-1,srcFile);
        fileTranPacket.feof=feof(srcFile);
        if(fileTranPacket.dataSize<0)
        {
            fclose(srcFile);
            return -2;
        }
        if(ex_send(&fileTranPacket,E_PROTO_FILE_TRAN)<=0)
            return -3;
    }
    fclose(srcFile);

    return 0;
}

int ServerComm::upload_scan_module()
{
    FILE *srcFile=NULL;
    char fileName[255],*p;

    if(strlen(this->options.scanModulePath)>0)
    {
        memset(fileName,NULL,sizeof(fileName));
        srcFile=fopen(this->options.scanModulePath,"rb");
        if(srcFile==NULL)
        {
            cout <<"can't open "<<this->options.scanModulePath<<endl;
            return -1;
        }
        p=strrchr(options.scanModulePath,'/');
        if(p!=NULL)
        {
            strcat(fileName,++p);
        }
        else
        {
            strcat(fileName,options.scanModulePath);
        }
        if(upload_file(srcFile,fileName,E_FILE_SCAN_MOD))
        {
            cout <<fileName<<" upload failed"<<endl;
            return -2;
        }
        cout <<fileName<<" upload successful"<<endl;
    }

    if(strlen(this->options.scanListPath)>0)
    {
        memset(fileName,NULL,sizeof(fileName));
        srcFile=fopen(this->options.scanListPath,"rb");
        if(srcFile==NULL)
        {
            cout <<"can't open "<<this->options.scanListPath<<endl;
            return -1;
        }
        p=strrchr(options.scanListPath,'/');
        if(p!=NULL)
        {
            strcat(fileName,++p);
        }
        else
        {
            strcat(fileName,options.scanListPath);
        }
        if(upload_file(srcFile,fileName,E_FILE_SCAN_LIST))
        {
            cout <<fileName<<" upload failed"<<endl;
            return -2;
        }
        cout <<fileName<<" upload successful"<<endl;
    }

    return 0;
}

int ServerComm::launch_scan_task()
{
    PROTO_LAUNCH_TASK launchPacket;

    memset(&launchPacket,NULL,sizeof(launchPacket));

    if(options.threadNum==0)
        options.threadNum=200;
    launchPacket.threadNum=options.threadNum;

    strcat(launchPacket.modName,options.modName);
    strcat(launchPacket.listName,options.listName);

    if(ex_send(&launchPacket,E_PROTO_LAUNCH_TASK)<=0)
        return -1;

    return 0;
}

int ServerComm::ex_send(void *buff,int proto)
{
    int sendSize,protoLen;
    PROTO_HEADER *pHeader=NULL;
    char sendBuffer[65536];

    memset(sendBuffer,NULL,sizeof(sendBuffer));
    pHeader=(PROTO_HEADER *)sendBuffer;

    pHeader->protoType=proto;
    protoLen=get_proto_len(proto);
    if(protoLen<=0)
        return -1;
    memcpy(sendBuffer+sizeof(PROTO_HEADER),buff,protoLen);

    pthread_mutex_lock(&sendMutex);
    sendSize=send(soc,sendBuffer,protoLen+sizeof(PROTO_HEADER),0);
    pthread_mutex_unlock(&sendMutex);

    return sendSize-sizeof(PROTO_HEADER);
}

RecvThread::RecvThread(SOCKET soc)
{
    this->soc=soc;
    this->recvHeader=1;
    this->nextRecvSize=sizeof(PROTO_HEADER);
    this->recvBuffer=NULL;
    pthread_mutex_init(&gl_EventListMutex,NULL);

    return;
}

void *RecvThread::func(void *Paramter)
{
    recv_message_from_server();
    return NULL;
}

int RecvThread::recv_message_from_server()
{
    int rSize;
    char *recvPointer=NULL;
    int proto;

    while(1)
    {
        if(this->recvBuffer==NULL)
        {
            this->recvSize=0;
            this->recvBuffer=(char *)malloc(this->nextRecvSize);
            if(this->recvBuffer==NULL) continue;
            memset(this->recvBuffer,NULL,this->nextRecvSize);
        }
        recvPointer=this->recvBuffer+this->recvSize;

        rSize=recv(this->soc,recvPointer,this->nextRecvSize-this->recvSize,0);
        if(rSize<=0)
        {
            //socket disable
            cout <<"remote host disconnect."<<endl;
            exit(0);
        }

        this->recvSize+=rSize;

        if(this->recvSize<this->nextRecvSize)
            continue;

        //recv finish
        if(this->recvHeader)
        {
            //recv protocol header
            printf("proto code :0x%.2x\n",((PROTO_HEADER *)this->recvBuffer)->protoType);
            this->nextRecvSize=get_proto_len(((PROTO_HEADER *)this->recvBuffer)->protoType);
            if(this->nextRecvSize<=0)
            {
                printf("Protocol mismatch,proto code :0x%.2x\n",((PROTO_HEADER *)this->recvBuffer)->protoType);
                exit(-1);
            }
            this->recvSize=0;
            this->recvHeader=0;
            proto=((PROTO_HEADER *)this->recvBuffer)->protoType;
            free(this->recvBuffer);
            this->recvBuffer=NULL;
        }
        else
        {
            //recv protocol data
            if(deal_protocol_data(proto)!=0)
                exit(0);

            free(this->recvBuffer);
            this->recvBuffer=NULL;
            this->recvHeader=1;
            this->nextRecvSize=sizeof(PROTO_HEADER);
            this->recvSize=0;
        }
    }
    return 0;
}

int RecvThread::deal_protocol_data(int proto)
{
    RECV_EVENT recvEvent;
    PROTO_CLIENT_AUTH *pClientAuth=NULL;
    PROTO_FILE_TRAN *pFileTran=NULL;
    PROTO_TASK_NODE_INSTR *pTaskInstr=NULL;
    PROTO_TASK_TARGET *pTaskTarget=NULL;

    memset(&recvEvent,NULL,sizeof(recvEvent));
    //printf("proto code:0x%.2x\n",proto);
    switch(proto)
    {
    case E_PROTO_CLIENT_AUTH:
        pClientAuth=(PROTO_CLIENT_AUTH *)recvBuffer;
        recvEvent.protocol=proto;
        recvEvent.pBuffer=(void *)recvBuffer;
        this->recvBuffer=NULL;

        pthread_mutex_lock(&gl_EventListMutex);
        gl_Event_List.push_back(recvEvent);
        pthread_mutex_unlock(&gl_EventListMutex);
        break;

    case E_PROTO_MESSAGE:
        cout <<(*(PROTO_MESSAGE *)recvBuffer).message<<endl;
        break;

    case E_PROTO_FILE_TRAN:
        pFileTran=(PROTO_FILE_TRAN *)recvBuffer;
        if(dstFile==NULL)
        {
            dstFile=fopen(pFileTran->fileName,"wb");
            if(dstFile==NULL)
            {
                cout <<"can't create "<<pFileTran->fileName<<endl;
                exit(-1);
            }
            else
            {
                cout <<"create \'"<<pFileTran->fileName<<"\' successful"<<endl;
                //getchar();
            }
        }
        fwrite(pFileTran->fileData,sizeof(char),pFileTran->dataSize,dstFile);
        if(pFileTran->feof)
        {
            fclose(dstFile);
            printf("file recv finish.\n");
            dstFile=NULL;
        }
        break;

    case E_PROTO_TASK_NODE_INSTR:
        pTaskInstr=(PROTO_TASK_NODE_INSTR *)recvBuffer;
        printf("instruct code:0x%.2x\n",pTaskInstr->instruct);
        if(pTaskInstr->instruct==E_TASK_LANUCH && pgl_Task==NULL)
        {
            pgl_Task=new Task(pTaskInstr->taskInfo);
            if(pgl_Task==NULL)
            {
                cout <<"new Task error."<<endl;
                exit(-1);
            }
            else
            {
                cout <<"create task success."<<endl;
            }
        }
        else if(pTaskInstr->instruct==E_TASK_DISTRI_FIN)
        {
            //SERVER distri task fin
            if(pgl_Task!=NULL)
            {
                pgl_Task->taskDistriFinFlag=1;
            }
            else
            {
                cout <<"task not found."<<endl;
            }
        }
        else
        {
            cout <<"instruct invalid."<<endl;
        }
        break;

    case E_PROTO_TASK_TARGET:
        pTaskTarget=(PROTO_TASK_TARGET *)recvBuffer;
        if(pgl_Task==NULL)
        {
            cout <<"Task object not found."<<endl;
            break;
        }
        pgl_Task->add_scan_target(*pTaskTarget);
        break;

    default:
        cout <<"Protocol mismatch."<<endl;
        return -1;
    }

    return 0;
}


void *wait_event(int protocol,int timeo)
{
    list<RECV_EVENT>::iterator iter;
    void *pRet=NULL;

    while(timeo)
    {
        pthread_mutex_lock(&gl_EventListMutex);
        for(iter=gl_Event_List.begin(); iter!=gl_Event_List.end(); iter++)
        {
            if((*iter).protocol==protocol)
            {
                pRet=(*iter).pBuffer;
                gl_Event_List.erase(iter);
                pthread_mutex_unlock(&gl_EventListMutex);
                return pRet;
            }
        }
        pthread_mutex_unlock(&gl_EventListMutex);
        usleep(1000);
        timeo-=1;
    }

    return NULL;
}

int get_proto_len(int proto)
{
    switch(proto)
    {
    case E_PROTO_CLIENT_AUTH:
        return sizeof(PROTO_CLIENT_AUTH);

    case E_PROTO_FILE_TRAN:
        return sizeof(PROTO_FILE_TRAN);

    case E_PROTO_LAUNCH_TASK:
        return sizeof(PROTO_LAUNCH_TASK);

    case E_PROTO_MESSAGE:
        return sizeof(PROTO_MESSAGE);

    case E_PROTO_TASK_NODE_INSTR:
        return sizeof(PROTO_TASK_NODE_INSTR);

    case E_PROTO_TASK_TARGET:
        return sizeof(PROTO_TASK_TARGET);

    case E_PROTO_TASK_REPORT:
        return sizeof(PROTO_TASK_REPORT);

    default:
        cout <<"can't get proto len,protocol mismatch."<<endl;
        return -1;
    }
}







